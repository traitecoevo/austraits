---
title: "usage"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{usage}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(austraits.R)
```


## Accessing data


load data
```{r}
data("austraits")
```

# Usage examples

The following section provides examples for users of `R` on manipulating the AusTraits dataset. Users of other platforms can follow similar steps using commands specific to their platform. 

We like using functions from packages like [dplyr](https://dplyr.tidyverse.org/), [readr](https://readr.tidyverse.org/), [tidyr](https://tidyr.tidyverse.org/) and [`magrittr`](https://magrittr.tidyverse.org/) in the [tidyverse](https://www.tidyverse.org/) to manipulate data. These packages can be loaded individually, or together by running:

```{r, eval=FALSE}
# install.packages("tidyverse")
library(tidyverse)
```

The examples below assume you have the tidyverse installed and loaded. This is not essential, but without these packages the examples below won't work.

For anyone needing to learn about the tidyverse, you will in particular want to read up on [dplyr](https://dplyr.tidyverse.org/) and [the pipe operator `%>%` from `magrittr`](https://magrittr.tidyverse.org/), which pipes output from one command into the next command.

## Taking subsets

Using the `dplyr`, it's easy to subset by rows using `filter`. This approach can be used to filter the data to particular trait or study:

```{r}
austraits$traits %>% 
  filter(trait_name == "leaf_area")
```

```{r}
austraits$traits %>% 
  filter(dataset_id == "Westoby_2014")
```

`filter` can also be used to select observations for a specific string of text, such as a single genus:

```{r}
austraits$traits %>% 
  filter(grepl("Acacia", taxon_name))
```

We can select particular columns from the whole or filtered dataset using `select`:

```{r}
austraits$traits %>% 
  select(taxon_name, observation_id, trait_name, value)
```

## Extracting a particular trait or study

The file `austraits.R` also include pre-built functions for extracting a particular trait or study. The difference with the examples above, is that these functions also subset the other tables and elements of the data, not just the main data table. So we need to provide the entire `austraits` object and a `dataset_id`:

```{r B14}
traits_B14 <- extract_dataset(austraits, "Falster_2003")
```

As with the the main `austraits` object, this new dataset has multiple elements:
```{r}
names(traits_B14)
```
but the length of the datasets is smaller:
```{r countrows}
count_rows <- function(obj) {c(nrow(obj$traits), nrow(obj$sites), nrow(obj$taxonomy))}
# main data
austraits %>% count_rows()
# subset
traits_B14 %>% count_rows()
```

A similar function enables sub-setting to a particular trait, including the various other tables:

```{r}
traits_LS <- extract_trait(austraits, "leaf_size")
```

As with the the main `austraits` object, this new dataset has multiple elements:
```{r}
names(traits_LS)
```
but the length of the datasets is smaller:
```{r}
# main data
austraits %>% count_rows()
# subset
traits_LS %>% count_rows()
```

## Merging with taxonomic data

Limited taxonomic information is provided in the main table `data`, only `original_name` (the original name provided by the authors) and `species_name` (the aligned taxonomic name; see [species taxonomy](#species_taxonomy) for details). But further information is available in the table `taxonomy`:

```{r}
austraits$taxa
```

You can merge this information in with the main dataset using the `species_name` as a an identifier linking both tables:

```{r taxonomic, results='show'}
traits2 <- austraits$traits %>% 
          left_join(by="taxon_name", austraits$taxa)

names(traits2)
```

Similarly we could merge in only family information by using `select` to reduce the second table before merging:

```{r taxonomic2, results='show'}
traits2 <- austraits$traits %>% 
          left_join(by="taxon_name", select(austraits$taxonomy, species_name, family))

names(traits2)
```

## Merging with location data

As with taxonomic information, limited information about location is provided in the main table `data`.  But further information is available in the table `context`:

```{r}
austraits$sites
```

As with the main table of trait data, this information is in long format. Depending on the study, a variety of contextual information may have been provided, including

```{r}
austraits$sites$site_property %>% table() %>% sort(decreasing=TRUE) %>% .[1:10]
```

In this example we'll just focus on location details. Before merging in with the main data table let's convert this data from long to wide format:

```{r}
sites <- austraits$sites %>% 
  filter(site_property %in%  c("longitude (deg)","latitude (deg)")) %>% 
  spread(site_property, value)
sites
```

We can now merge in with the main data table using combinations of `dataset_id` and `site_name` as identifiers from both tables:

```{r}
traits_sites <- left_join(by=c("dataset_id", "site_name"), austraits$traits, sites)

names(traits_sites)
```

## Removing suspected duplicates

AusTraits compiles data from many different sources and not all of these will be unique. Data from one study may be repeated in another. We have provided a workflow for removing suspected duplicate data via the function `remove_suspected_duplicates`. The function takes as an argument the entire `austraits` object and returns a modified object in which suspected duplicates have been moved from the main `traits` table to the `excluded_data` table, noting  the `observartion_id` of the matching data in the error column. To use this function you mast pass in the entire `austraits` object:


```{r}
austraits_deduped <- remove_suspected_duplicates(austraits)
```

Suspected duplicates are identified based on identical matches between the variables `species_name`, `trait_name`, and `value`.  Priority is given to older sources, as indicated by the year in the `dataset_id`.

Checking the number of rows in original dataset and modified dataset we can see that `r nrow(austraits_deduped$excluded_data) - nrow(austraits$excluded_data)` records have been removed from `traits`:

```{r}
c(traits = nrow(austraits$traits), 
  excluded = nrow(austraits$excluded_data), 
  total = nrow(austraits$traits)+ nrow(austraits$excluded_data))

c(traits = nrow(austraits_deduped$traits), 
    excluded = nrow(austraits_deduped$excluded_data), 
  total = nrow(austraits_deduped$traits)+ nrow(austraits_deduped$excluded_data))
```

## Converting from long to wide format

As discussed above, the main data table in `austraits` is distributed in long format. A long format has each measurement on a different row, and just a single column for all the value. By contrast, a dataset in wide format has data for each different trait in it's own column. The reason we use long format is mainly for efficiency. We have data from `r austraits$traits$trait_name %>% unique() %>% length()` different traits, so in wide format we'd need at least this many columns. With many species, the file size gets very large very quickly. Other benefits of long format are that we can include columns for `units`, `value_type`, and `replicates`, which we could not in wide format (without created 3 more columns for each traits). 

For many analyses, however, you'll want to use wide format. We have therefore provided the ability to convert between the two formats. In wide format, each trait appears in it's own column and measurements from the same observation (ideally individual, but in floras may be a species) appear on the same row.  

As the entire austraits dataset is quite large, we recommend first sub-setting the data before spreading from long to wide format. You may also need to reduce the number of measurements in any one observation (see next section). For this first example we'll use the dataset `Westoby_2014`. 

First extract the trait data from the `Westoby_2014` study:

```{r}
data <- austraits$traits %>% 
  filter(dataset_id == "Falster_2003")
data
```
Now use the inbuilt function `spread_trait_data` to convert from long to wide:

```{r}
traits_spread <- spread_trait_data(data)
```
This function spreads not only the data in the column `value`, but also other columns. The returned object is a list with a number of wide tables:

```{r}
names(traits_spread)
```
Looking at each of these we see a table in wide format (i.e. with each trait being a column), as well as identifying columns at the start:
```{r}
traits_spread$value
```
The other tables have an identical format

```{r}
traits_spread$unit
```
...etc

The new dataset can then be used to plot traits against each other, e.g.
```{r, warning=FALSE}
traits_spread$value %>%
  mutate(specific_leaf_area = as.numeric(specific_leaf_area), 
         photosynthetic_rate_per_area = as.numeric(photosynthetic_rate_per_area)) %>%
  ggplot(aes(x=specific_leaf_area, y = photosynthetic_rate_per_area, colour =site_name)) +
  geom_point()
```

There is also a function to convert back from wide to long format:

```{r}
traits2 <- gather_trait_data(traits_spread, austraits$definitions)
```

This manipulation should recover the original dataset.

Original:
```{r}
traits2
```
After conversion
```{r}
data
```
Just to be sure we can run a check:
```{r}
all.equal(data, traits2)
```

Note that the function `gather_trait_data` also needs the element `austraits$definitions` to run successfully. 

### Datasets with multiple measurements per observation

The above example works easily because there is only a single measurement of each trait per `observation_id`. But this is not always the case. Many datasets include multiple records per `observation_id`, for example studies reporting multiple `value_types` per `observation_id`. An example is the `AusGrass_2014` datasets:

```{r}
traits <- austraits$traits %>% 
  filter(dataset_id == "AusGrass_2014")
traits
```
Note the dataset includes multiple value_types: `expert_min` and `expert_max`. If you try running `spread_trait_data` on this data it will fail: 

```{r, eval=FALSE}
traits_spread <- spread_trait_data(traits)
```
```
## Error: Duplicate identifiers for rows (2929, 2930), (2936, 2937), (3015, 3016), (2975, 2976), ....
```

So before converting from long to wide we use an additional function called `bind_trait_values` to collapse all the different measurements for a given `trait_name` and `observation_id` into a single cell:

```{r}
traits_bind <- bind_trait_values(traits)
```
This function binds data from multiple rows together, separating with the string ``--`. This occurs for columns `value`, `value_type`, and `replicates`. Looking at the table we can see the bound values:

```{r}
traits_bind %>% 
  filter(grepl("--", value_type)) %>% 
  select(-dataset_id, -site_name, -original_name)
```

Using this new dataset we can now go from long to wide:

```{r}
traits_spread <- spread_trait_data(traits_bind)
```

The bound data values are carried over to the new dataset:
```{r}
traits_spread$value
```

As previously, we can also convert back again:

```{r}
traits_bind2 <- gather_trait_data(traits_spread, austraits$definitions)
```

Thsi gets us back to the intermediate dataset
```{r}
all.equal(traits_bind, traits_bind2)
```

And then finally we can separate out the values that have been bound together:

```{r}
traits2 <- separate_trait_values(traits_bind2, austraits$definitions)
```

We should now have a dataset identical to our original. Just to be sure we can run a check:
```{r}
all.equal(traits, traits2)
```

Using pipes we can put all these steps together to short the full range of steps:
 
```{r}
traits %>% 
 bind_trait_values() %>% 
 spread_trait_data() %>% 
 gather_trait_data() %>% 
 separate_trait_values(austraits$definitions) -> traits2

all.equal(traits, traits2)
```
